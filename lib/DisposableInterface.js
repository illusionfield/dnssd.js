"use strict";function _typeof(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function");}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:true,configurable:true}});if(superClass)_setPrototypeOf(subClass,superClass);}function _setPrototypeOf(o,p){_setPrototypeOf=Object.setPrototypeOf||function _setPrototypeOf(o,p){o.__proto__=p;return o;};return _setPrototypeOf(o,p);}function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _possibleConstructorReturn(self,call){if(call&&(_typeof(call)==="object"||typeof call==="function")){return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return true;}catch(e){return false;}}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}var os=require('os');var dgram=require('dgram');var NetworkInterface=require('./NetworkInterface');var filename=require('path').basename(__filename);var debug=require('./debug')("dnssd:".concat(filename));/**
 * Creates a network interface obj using some ephemeral port like 51254
 * @class
 * @extends NetworkInterface
 *
 * Used for dnssd.resolve() functions where you only need to send a query
 * packet, get an answer, and shut down. (Sending packets from port 5353
 * would indicate a fully compliant responder). Packets sent by these interface
 * objects will be treated as 'legacy' queries by other responders.
 */var DisposableInterface=/*#__PURE__*/function(_NetworkInterface){_inherits(DisposableInterface,_NetworkInterface);var _super=_createSuper(DisposableInterface);function DisposableInterface(name,addresses){var _this;_classCallCheck(this,DisposableInterface);debug("Creating new DisposableInterface on ".concat(name,":"));_this=_super.call(this,name);_this._addresses=addresses;return _this;}/**
   * Creates/returns DisposableInterfaces from a name or names of interfaces.
   * Always returns an array of em.
   * @static
   *
   * Ex:
   * > const interfaces = DisposableInterface.createEach('eth0');
   * > const interfaces = DisposableInterface.createEach(['eth0', 'wlan0']);
   *
   * @param  {string|string[]} args
   * @return {DisposableInterface[]}
   */_createClass(DisposableInterface,[{key:"bind",value:function bind(){var _this2=this;return Promise.all(this._addresses.map(function(addr){return _this2._bindSocket(addr);})).then(function(){debug("Interface ".concat(_this2._id," now bound"));_this2._isBound=true;});}},{key:"_bindSocket",value:function _bindSocket(address){var _this3=this;var isPending=true;var promise=new Promise(function(resolve,reject){var socketType=address.family==='IPv6'?'udp6':'udp4';var socket=dgram.createSocket({type:socketType});socket.on('error',function(err){if(isPending)reject(err);else _this3._onError(err);});socket.on('close',function(){_this3._onError(new Error('Socket closed unexpectedly'));});socket.on('message',_this3._onMessage.bind(_this3));socket.on('listening',function(){var sinfo=socket.address();debug("".concat(_this3._id," listening on ").concat(sinfo.address,":").concat(sinfo.port));_this3._sockets.push(socket);resolve();});socket.bind({address:address.address});});return promise.then(function(){isPending=false;});}}],[{key:"create",value:function create(name){var addresses=[{adderss:'0.0.0.0',family:'IPv4'}// {adderss: '::', family: 'IPv6'},
];return name?new DisposableInterface(name,os.networkInterfaces()[name]):new DisposableInterface('INADDR_ANY',addresses);}/**
   * Checks if the names are interfaces that exist in os.networkInterfaces()
   * @static
   *
   * @param  {string|string[]} arg - interface name/names
   * @return {boolean}
   */},{key:"isValidName",value:function isValidName(name){if(!name||typeof name!=='string')return false;return!!~Object.keys(os.networkInterfaces()).indexOf(name);}}]);return DisposableInterface;}(NetworkInterface);module.exports=DisposableInterface;